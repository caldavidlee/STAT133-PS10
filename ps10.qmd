---
title: "Problem Set 10"
format: 
    dashboard:
        orientation: columns
        nav-buttons: 
            - icon: github
              href: https://github.com/caldavidlee/STAT133-PS10
            - icon: linkedin
              href: https://www.linkedin.com/in/davidthelee/
            - icon: twitter
              href: http://x.com/divarnold/
        logo: stat133_logo-main.png
author: David Lee
theme: minty
---

# PS 10 — Gerrymandering

**STAT 133**

Practice related to this lecture is found in the worksheet associated with Project: Gerrymandering.

```{r}
#install.packages(c('sf', 'rnaturalearth'))
library(tidyverse)
library(sf)
library(rnaturalearth)

```

## Spatial II

The following exercises serve as an introduction to the functionality of the **sf** package. Anytime you use a new function, use `?` to learn how it works. Some of these exercises ask you to plot the result — plots are provided to check your answer.

1. Following the approach used in lecture, use `st_linestring()` to create two separate line segments called:
   - `l1`: stretches from (0, 0) to (1, 1)
   - `l2`: stretches from (0, 1) to (1, 0)  
   View them using base R `plot()`.
    > Each object will require a separate call to `plot()`.  
   > You can add `add = TRUE` to `plot()` so that the contents of the second get added to the first.  
   > Note that these plot additions don’t carry over from code cell to code cell.
   ```{r}
    l1 <- st_linestring(matrix(c(0,0,1,1), ncol = 2, byrow = TRUE))
    l2 <- st_linestring(matrix(c(0,1,1,0), ncol = 2, byrow= TRUE))
    #plot(c(l1,l2))
    plot(l1)
    plot(l2, add = TRUE)
   ```

 2. Form a spatial data frame (an object with classes `sf` and `data.frame`) called **my_lines** with two columns:
   - `id`: an attribute with values 1 and 2.
   - `geom`: a simple feature (geometry) column containing the two lines with the coordinate reference system `OGC:CRS84`.


```{r}
id <- c(1,2)
geom <- st_sfc(list(l1,l2), crs = 'OGC:CRS84')
my_lines <- st_sf(id= id, geom=geom)
plot(st_geometry(my_lines), pch=16)


```

 3. Create a second spatial data frame with a diamond-shaped polygon.  
   The diamond should have corners at (.5, .8), (.3, .5), (.5, .2), and (.7, .5) and use the same CRS.  
   It should have an attribute called `price` with the value **100**.  
   Call your spatial data frame **my_diamond** and plot it atop your lines.
```{r}

diamond <- matrix(c(.5,.8, .3,.5,.5,.2,.7,.5, .5,.8),ncol = 2, byrow = TRUE)
diamond <- st_polygon(list(diamond))
diamond_sfc <- st_sfc(diamond, crs = 'OGC:CRS84')
price <- 100
my_diamond <- st_sf(price = price, geom = diamond_sfc)
plot(st_geometry(my_diamond), lwd = 5)
plot(st_geometry(my_lines), add = TRUE)

```

 4. Calculate the **dimension**, **length**, and **area** of `my_lines()`.
 ```{r}
cat("Dimension: ", st_dimension(my_lines), "\n")
cat("Length: ", st_length(my_lines),"\n")
cat("Area: ",st_area(my_lines), "\n")

 ```

 5. Calculate the **dimension**, **length**, and **area** of `my_diamond()`.
 ```{r}
cat("Dimension: ", st_dimension(my_diamond), "\n")
cat("Length: ", st_length(my_diamond),"\n")
cat("Area: ",st_area(my_diamond), "\n")

 ```

 6. Use the `st_split()` function inside the **lwgeom** package to split the diamond into four diamonds using your lines.  
   Name the resulting object **split_diamond**. 
   
> You can add colors to `plot()` using the `col` argument and call `colors()` at the console to see the color names available in base R.  
> Example: `col = c("skyblue", "tomato")` but you’re welcome to pick your own colors.

After inspecting the result, run:

```{r}
#| echo: false
#install.packages('lwgeom')
library(lwgeom)
```
```{r}
    split_diamond <- st_split(my_diamond, my_lines)
    split_diamond <- split_diamond |>
       st_collection_extract("POLYGON")
    plot(split_diamond, col = c("pink4", "plum", "purple2", "rosybrown"))
```
Plot the resulting `sf` collection of 4 features, with each of the split diamonds filled with a color.


 7.
Add two attribute columns to `split_diamonds`:

- 1. `yield`: takes values of 10, 20, 30, and 40 for the top, right, bottom, and left split diamonds, respectively.  
   (You can imagine this is the yield of four fields of corn.)

- 2. `split_price`: the original price of the full diamond scaled by the relative area of each of the four split diamonds.  
   Round the split price to the nearest cent.

Be sure to save the new columns back into `split_diamonds`.

```{r}
# SKIPPED
#st_split(my_diamond, st_union(my_lines)) |>

#split_diamonds <- st_sf(yield = c(10,20,30,40), split_price = price * split_diamond)

```

8. Compute the **centroids** of the four split diamonds, call them `my_cents`, and add them to your plot. Set their `col` and `pch` as you like.
```{r}
plot(
  st_geometry(split_diamond),
  col = c("pink4", "plum", "purple2", "rosybrown"),
  border = "gray20", lwd = 1.5,
  reset = FALSE
)
my_cents <- points(st_geometry(st_centroid(split_diamond)), pch = 16, col = c("seagreen1","seagreen1","seagreen1","seagreen1"))

```
---

 9.
Using what you know about data frame subsetting, remove the **bottom-most centroid**.  
Then take the **union** of the three remaining points, form a **convex hull** from them, and save the polygon to `my_tri_up`.  
> The functions for these set operations in `sf` are exactly as you’d expect:  
> the name of the operation prepended by `st_`.  
> Note also that the union operation will drop the `sf` class — you’ll need to run your object through `st_sf()` to get it back.
Plot `my_tri_up` on top of your split diamond.

```{r}


```


10. Repeat the previous exercise, but form an `sf` object called `my_tri_down` that has the **top-most centroid** removed.
```{r}


```

11. Under the definition of **“intersects,”** determine which of your split diamonds intersect with `my_tri_up`.  
Check by doing a **spatial join**.
```{r}


```


12. Calculate the **area** of `my_tri_up` two ways:

1. By directly measuring the area of the triangle.  
2. By interpolating from the `area` attribute of the split diamonds that it intersects with.
```{r}


```
Do they agree?
- SKIPPED
---

 13.
Calculate the **yield** of both `my_tri_up` and `my_tri_down` by interpolating from the yield of the split diamonds that they intersect with.  
Why are they different from one another?

> When interpolating, you’ll need to decide whether your variable is **spatially extensive**.  
> An attribute that is spatially extensive has a magnitude proportional to the size of the feature it’s measured on;  
> as the area of the feature increases, the magnitude of the attribute increases proportionally.
```{r}


```
---


```{r}
#install.packages(c("gt", "httr2", "shiny"))

```
```{r}
#| label: setup
#| message: false
library(tidyverse)
library(httr2)
library(sf)
library(leaflet)
library(gt)
library(shiny)
```

```{r}
#| label: "Get quake data"
quakes_raw <- request("https://api.geonet.org.nz/quake?MMI=3") |>
  req_headers("Accept"="application/vnd.geo+json") |>
  req_perform() |>
  resp_body_string() |> 
  st_read(quiet = TRUE)
```

```{r}
#| label: "Prettier date/times"
recent_quakes <- quakes_raw |> 
  arrange(desc(time)) |> 
  mutate(
    time = force_tz(time, "Pacific/Auckland"),
    pretty_time = format(time, "%I:%M %p"),
    days_ago = today(tzone = "Pacific/Auckland") - date(time),
    days_ago = case_when(
      days_ago == 0 ~ "Today",
      days_ago == 1 ~ "Yesterday",
      TRUE ~ paste0(days_ago, " days ago")
    )
  )
```

```{r}
#| label: "Summary stats"
now_nz <- now(tzone = "Pacific/Auckland")
last_24 <- recent_quakes |> 
    filter(time > (now_nz - hours(24)))
n_24 <- nrow(last_24)
hours_last <- round(difftime(now_nz, recent_quakes$time[1], units = "hours"))
```

```{r}
#| label: "Quake map"
mag_pal <- colorBin("inferno", domain = 1:8, bins = c(0:5, 8))

quake_map <- recent_quakes |> 
  leaflet() |> 
  addCircleMarkers(
    color = ~ mag_pal(magnitude),
    stroke = FALSE,
    fillOpacity = 0.5,
    radius = ~ scales::rescale(sqrt(magnitude), c(1, 10)),
    label = ~ paste(
      date(time), pretty_time, "<br/>",
      "Magnitude:", round(magnitude, 1), "<br/>", 
      "Depth:",  round(depth), " km"
      ) |> map(html),
    labelOptions = c(textsize = "15px")) |> 
  addLegend(title = "Magnitude", colors = mag_pal(0:5), labels = c("<1", 1:4,">5")) |> 
  addTiles("http://services.arcgisonline.com/arcgis/rest/services/Canvas/World_Light_Gray_Base/MapServer/tile/{z}/{y}/{x}", options = tileOptions(minZoom = 5, maxZoom = 10)) 
```

```{r}
#| label: "Quake histogram"
mag_hist <- recent_quakes |> 
  ggplot(aes(x = magnitude)) +
  geom_histogram()
```

```{r}
#| label: "Quake timeline"
timeline <- recent_quakes |> 
  ggplot(aes(x = time, y = 0)) +
  geom_point()
```

```{r}
#| label: "Recent quakes table"
n <- 10
top_n <- recent_quakes |> 
  slice(1:n) |> 
  as.data.frame() |> 
  select(magnitude, days_ago, pretty_time, locality, depth) 

top_n_table <- top_n |> 
  gt() |> 
  cols_label(
    days_ago = "",
    locality = "Location",
    magnitude = "Magnitude",
    depth = "Depth",
    pretty_time = ""
  ) |> 
  fmt_integer(
    columns = depth, 
    pattern = "{x} km"
  ) |> 
  fmt_number(
    columns = magnitude,
    decimals = 1
  ) |> 
  data_color(
    columns = "magnitude",
    fn = mag_pal
  ) |>
  tab_header(
    title = md("**Last 10 Earthquakes**")
  ) |> 
  tab_source_note(
    source_note = md(paste("Retrieved from the [GeoNet API](https://api.geonet.org.nz/) at", format(now_nz, "%Y/%m/%d %H:%M %Z")))
  )
```

# Dashboard

## Column 1 {height = 50%}

### 
```{r}
#| component: valuebox
#| title: Number of Hours since last Earthquake
list(icon = "clock-history", color = "primary", value = as.numeric(hours_last))

```

```{r}
#| component: valuebox
#| title: Number of Earthquakes in the last 24 hours
list( icon = "activity", color = "primary", value = n_24)
```

### Sub-Column
```{r}
#| title: Top 10 Earthquakes
#| component: table
#| echo: false
top_n_table



```

## Column 2 {height = 100%}
```{r}
quake_map
```


# About the Data
The original author of this dashboard is **Charlotte Wickham**.  
The data on earthquakes is drawn from the **GeoNet API**: <https://api.geonet.org.nz/>  
All earthquakes below **MMI 3.0** have been filtered out.

**References**

- <https://github.com/berkeley-stat133/demo-dashboard>  
- <https://api.geonet.org.nz/>  
- <https://quarto.org/docs/dashboards/theming.html>  
- <https://icons.getbootstrap.com/>
- [Shapefiles that ESRI ArcView GIS typically uses - they give you 8+ files but only read the .shp file- it will read the rest]<https://data.ca.gov/dataset/ca-geographic-boundaries>

### 
**Dashboard Requirements**

Starting from the contents of `demo-dashboard.qmd` found in the corresponding repo  
(<https://github.com/berkeley-stat133/demo-dashboard>), create a data dashboard that provides information on the most recent earthquakes to strike **New Zealand**.

The dashboard should include:

1. **Your name** added as the author.  
2. **A theme** of your choosing.  
   > Dashboards collect the colors and fonts into themes similar to ggplot2.  
   > You can find the list of themes here:  
   > <https://quarto.org/docs/dashboards/theming.html>.
3. **A layout in two columns.**
4. The **map of New Zealand** taking up the full right column.
5. The **left column** should have two rows:
   - The **top row** has **value boxes** for:
     - the **number of hours since the last earthquake**, and  
     - the **number of earthquakes in the last 24 hours**.  
       Select a suitable **icon** for each.
       > Quarto dashboards can use any of the icons in the Bootstrap collection.  
       > Search for an icon and use the corresponding name as a string:  
       > <https://icons.getbootstrap.com/>.
   - The **bottom row** should hold the **table of the top n earthquakes**.
6. All of the above should appear on a page called **“Dashboard.”**  
   Add a second page called **“About the data”** that displays the following text:

   > The original author of this dashboard is **Charlotte Wickham**.  
   >  
   > The data on earthquakes is drawn from the **GeoNet API**:  
   > <https://api.geonet.org.nz/>  
   >  
   > All earthquakes below **MMI 3.0** have been filtered out.

Since it is quite lengthy, there is **no need to copy the code** used in your dashboard into this problem set.